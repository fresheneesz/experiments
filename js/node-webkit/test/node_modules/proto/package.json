{
  "name": "proto",
  "version": "1.0.4",
  "main": "proto.js",
  "description": "A prototype-based inheritance library that makes it easy to create objects and inheritance hierarchies without losing the power of javascript's prototype system.",
  "keywords": [
    "class",
    "inheritance",
    "prototype",
    "javascript",
    "superclass",
    "parent",
    "child",
    "inherit"
  ],
  "dependencies": {
    "buildModules": "git+https://git@github.com/fresheneesz/buildModules.git#2f50ea0830b0fa580c087b4bfa947de2e7b7d7c3"
  },
  "devDependencies": {
    "deadunit": "git+https://git@github.com/fresheneesz/deadunit.git"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/fresheneesz/proto"
  },
  "scripts": {
    "postinstall": "node build.js"
  },
  "readme": "`proto`\r\n=====\r\n\r\nA prototype-based inheritance/class library that makes it easy to create objects and inheritance hierarchies without losing the\r\npower of javascript's prototype system. \r\n\r\nWhy Use proto?\r\n==============\r\n* `instanceof` works with `proto` classes\r\n* constructors are inheritable\r\n* non-objects can be returned from a constructor (even `undefined`)!\r\n* easy access to an object's superclass\r\n* you don't hafta use the `new` operator\r\n* native objects work with `proto`. `proto` properly* creates classes that inherit from native objects - even all the `Error` types. *_Inheriting javascript objects has some limitations (see below)_\r\n* [`prototype` and `constructor` properties][javascriptFunctionProperties] are propertly set\r\n* `proto` doesn't use `Object.create` so it should work with older browsers ( *testers welcome!* )\r\n* `proto` is small: ( __896 bytes minified and in AMD format__ )\r\n* `proto` is lightweight. It doesn't attempt to emulate class-based languages or create any fancy features you probably don't actually need (interfaces, abstract classes, etc)\r\n\r\n[javascriptFunctionProperties]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/prototype\r\n\r\nExample\r\n=======\r\n\r\n```\r\nvar Person = proto(function() {       // prototype builder\r\n    this.init = function(legs, arms) {      // constructor\r\n        this.legs = legs\r\n        this.arms = arms\r\n    }\r\n\r\n    this.getCaughtInBearTrap = function() { // instance method\r\n        this.legs -= 1\r\n    }\r\n    this.limbs = function() {\r\n        return this.arms + this.legs\r\n    }\r\n})\r\n\r\nvar Girl = proto(Person, function() { // inheritance\r\n    this.haveBaby = function() {\r\n        return Person(2,2)\r\n    }\r\n})\r\n\r\nvar g = Girl(2,2)        // instantiation\r\ng.getCaughtInBearTrap()\r\nconsole.log(\"Girl has \"+g.limbs()+\" limbs\")\r\nconsole.log(\": (\")\r\n\r\nvar newPerson = g.haveBaby()\r\nconsole.log(\"New person has\" +newPerson.limbs()+\" limbs : )\")\r\n ```\r\n\r\n\r\nInstall\r\n=======\r\n\r\n```\r\nnpm install proto\r\n```\r\n\r\n\r\nUsage\r\n=====\r\n\r\nAccessing proto:\r\n```\r\nvar proto = require('proto') // node.js\r\n\r\ndefine(['proto'], function(proto) { ... } // amd\r\n\r\nproto; // proto.global.js defines proto globally if you really \r\n       //   want to shun module-based design\r\n```\r\n\r\nUsing proto:\r\n```\r\nvar Parent = proto(function() {\r\n    this.init = function(v) {   // constructor\r\n        if(v > 0) {\r\n            this.x = v                // you can normally access the object with this inside methods\r\n        } else if(v !== undefined) {\r\n\t\t\treturn true\t              // you can return non-object values\r\n\t\t} else {\r\n\t\t\treturn proto.undefined    // return undefined by using a special constructor return value\r\n\t\t}\r\n    }\r\n   \r\n    this.anythingElse = 5   // static properties can be accessed by the class and the instance\r\n\r\n\tvar that = this // private functions don't have access to the correct 'this', so pass it in\r\n    var privateFn = function(me, arg1, etc) {  \r\n        that.x = arg1 + etc\r\n    }\r\n    this.doSomething = function() {\r\n        privateFn(this, this.x, 1)\r\n    }\r\n})\r\n\r\n// you can inherit from any object!\r\n// the resulting object factory will generate instances inheriting from:\r\n    // [if you inherit from]\r\n        // [a function]: that function's prototype\r\n        // [anything else]: that object itself\r\nvar Child = proto(Parent, function(superclass) {\r\n    this.init = function() {\r\n        superclass.init.call(this, arguments) // super-class method call\r\n        this.r = 10\r\n        return this\r\n    }\r\n\t\r\n\t// create static methods just like instance methods - you can access them from the constructor\r\n    this.staticMethod = function(x) {        \r\n        return this.constructor(x+12)        // uses its own constructor to create a Child object\r\n    }\r\n})\r\n\r\nvar object = Child(1)                // instantiation\r\nobject.doSomething()                  // method call (as usual)\r\nvar object2 = Child.staticMethod(1)  // static method call\r\n\r\n ```\r\n\r\n\r\nLimitations of `proto`\r\n=============================================\r\n* Inheriting from `Error` and other exception types doesn't automatically set a correct `name` property, so you need to set it in the contructor manually.\r\n* Objects inheriting from `String` can't use the `toString` method. \r\n* Inheriting from `Array` doesn't work.\r\n* Inheriting from `RegExp` doesn't work either (the results can't use the `test` or `match methods).\r\n* You can't properly access any non-writable properties of a function from the returned proto-object factory though the properties will work correctly on instances. This includes: `name`, `length`, `arguments`, and `caller`.\r\n \r\n\r\nContributors\r\n============\r\n* Special thanks to [jayferd][jayferd], since I got most of the unit tests for `proto` from [his `pjs` project][pjs].\r\n\r\n\r\n[jayferd]: https://github.com/jayferd\r\n[pjs]: https://github.com/jayferd/pjs\r\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/fresheneesz/proto/issues"
  },
  "_id": "proto@1.0.4",
  "_from": "proto@"
}
