// Generated by CoffeeScript 1.6.3
var Dependency, ModuleGeneratorTemplates, ModuleManipulator, UError, UModule, UResource, fs, l, upath, _, _B, _ref,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

_ = require('lodash');

_B = require('uberscore');

l = new _B.Logger('urequire/UModule');

fs = require('fs');

upath = require('../paths/upath');

ModuleGeneratorTemplates = require('../templates/ModuleGeneratorTemplates');

ModuleManipulator = require("../moduleManipulation/ModuleManipulator");

UResource = require('./UResource');

Dependency = require("../Dependency");

UError = require('../utils/UError');

UModule = (function(_super) {
  __extends(UModule, _super);

  function UModule() {
    _ref = UModule.__super__.constructor.apply(this, arguments);
    return _ref;
  }

  Function.prototype.property = function(p) {
    var d, n;
    for (n in p) {
      d = p[n];
      Object.defineProperty(this.prototype, n, d);
    }
    return null;
  };

  UModule.property({
    modulePath: {
      get: function() {
        return upath.trimExt(this.filename);
      }
    }
  });

  /*
    Check if `super` in UResource has spotted changes and thus has a possibly changed @converted (javascript code)
    & call `@adjustModuleInfo()` if so.
  
    It does not actually convert to any template, as it waits for instructions from the bundle
  
    But the module can provide deps information (eg to inject Dependencies etc)
  */


  UModule.prototype.refresh = function() {
    if (UModule.__super__.refresh.apply(this, arguments)) {
      if (this.sourceCodeJs !== this.converted) {
        this.sourceCodeJs = this.converted;
        this.adjustModuleInfo();
        return this.hasChanged = true;
      } else {
        if (l.deb(90)) {
          l.debug("No changes in sourceCodeJs of module '" + this.dstFilename + "' ");
        }
      }
    }
    return this.hasChanged = false;
  };

  UModule.prototype.reset = function() {
    UModule.__super__.reset.apply(this, arguments);
    return delete this.sourceCodeJs;
  };

  /*
  Extract AMD/module information for this module.
  Factory bundleRelative deps like `require('path/dep')` are replaced with their fileRelative counterpart
  Extracted module info augments this instance.
  */


  UModule.prototype.adjustModuleInfo = function() {
    var d, pd, repData, strDep, strDepsArray, _base, _base1, _i, _j, _len, _len1, _ref1, _ref2, _ref3, _ref4;
    if (l.deb(70)) {
      l.debug("adjustModuleInfo for '" + this.dstFilename + "'");
    }
    this.moduleManipulator = new ModuleManipulator(this.sourceCodeJs, {
      beautify: true
    });
    this.moduleInfo = this.moduleManipulator.extractModuleInfo();
    if (_.isEmpty(this.moduleInfo)) {
      return l.warn("Not AMD/nodejs module '" + this.filename + "', copying as-is.");
    } else if (this.moduleInfo.moduleType === 'UMD') {
      return l.warn("Already UMD module '" + this.filename + "', copying as-is.");
    } else if (this.moduleInfo.untrustedArrayDeps) {
      return l.err("Module '" + this.filename + "', has untrusted deps " + ((function() {
        var _i, _len, _ref1, _results;
        _ref1 = this.moduleInfo.untrustedArrayDeps;
        _results = [];
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          d = _ref1[_i];
          _results.push(d);
        }
        return _results;
      }).call(this)) + ": copying as-is.");
    } else {
      this.isConvertible = true;
      (_base = this.moduleInfo).parameters || (_base.parameters = []);
      (_base1 = this.moduleInfo).arrayDeps || (_base1.arrayDeps = []);
      if (_.isEmpty(this.moduleInfo.arrayDeps)) {
        this.moduleInfo.parameters = [];
      } else {
        this.moduleInfo.parameters = this.moduleInfo.parameters.slice(0, +(this.moduleInfo.arrayDeps.length - 1) + 1 || 9e9);
      }
      _ref1 = [this.moduleInfo.parameters, this.moduleInfo.arrayDeps];
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        pd = _ref1[_i];
        if (pd[0] === 'require') {
          pd.shift();
        }
      }
      _ref2 = (function() {
        var _j, _len1, _ref2, _results;
        _ref2 = [this.moduleInfo.arrayDeps, this.moduleInfo.requireDeps, this.moduleInfo.asyncDeps];
        _results = [];
        for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
          strDepsArray = _ref2[_j];
          _results.push((function() {
            var _k, _len2, _ref3, _results1;
            _ref3 = strDepsArray || [];
            _results1 = [];
            for (_k = 0, _len2 = _ref3.length; _k < _len2; _k++) {
              strDep = _ref3[_k];
              _results1.push(new Dependency(strDep, this.filename, this.bundle));
            }
            return _results1;
          }).call(this));
        }
        return _results;
      }).call(this), this.arrayDependencies = _ref2[0], this.requireDependencies = _ref2[1], this.asyncDependencies = _ref2[2];
      if (this.bundle.reporter) {
        _ref3 = [_.pick(this.moduleInfo, this.bundle.reporter.reportedDepTypes)];
        for (_j = 0, _len1 = _ref3.length; _j < _len1; _j++) {
          repData = _ref3[_j];
          this.bundle.reporter.addReportData(repData, this.modulePath);
        }
      }
      this.parameters = _.clone(this.moduleInfo.parameters);
      this.nodeDependencies = _.clone(this.arrayDependencies);
      _ref4 = this.moduleInfo, this.moduleName = _ref4.moduleName, this.moduleType = _ref4.moduleType, this.modulePath = _ref4.modulePath, this.rootExports = _ref4.rootExports, this.noConflict = _ref4.noConflict;
      this.rootExports = _B.arrayize(this.rootExports);
      return null;
    }
  };

  /*
  Actually converts the module to the target @build options.
  */


  UModule.prototype.convert = function(build) {
    var bundleExports, d, dep, depName, depsVars, lenDiff, paramIndex, reqDep, requireReplacements, uerr, varName, _i, _j, _k, _l, _len, _len1, _len2, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8;
    this.build = build;
    if (this.isConvertible) {
      if (l.deb(30)) {
        l.debug("Preparing conversion of '" + this.modulePath + "' with template '" + this.build.template.name + "'");
      }
      if (!_.isEmpty((bundleExports = (_ref1 = this.bundle) != null ? (_ref2 = _ref1.dependencies) != null ? (_ref3 = _ref2.exports) != null ? _ref3.bundle : void 0 : void 0 : void 0))) {
        if (l.deb(80)) {
          l.debug("" + this.modulePath + ": injecting dependencies \n", this.bundle.dependencies.exports.bundle);
        }
        for (depName in bundleExports) {
          depsVars = bundleExports[depName];
          if (_.isEmpty(depsVars)) {
            depsVars = bundleExports[depName] = this.bundle.getDepsVars(function(dep) {
              return dep.depName === depName;
            })[depName];
            if (l.deb(40)) {
              l.debug("" + this.modulePath + ": dependency '" + depName + "' had no corresponding parameters/variable names to bind with.\nAn attempt to infer depsVars from bundle: ", depsVars);
            }
          }
          if (_.isEmpty(depsVars)) {
            l.err(uerr = "No variable names can be identified for `dependencies: exports: bundle` dependency '" + depName + "'.\n\nThese variable names are used to :\n  - inject the dependency into each module\n  - grab the dependency from the global object, when running as <script>.\n\nRemedy:\n\nYou should add it at uRequireConfig 'bundle.dependencies.exports.bundle' as a\n  ```\n    dependencies: exports: bundle: {\n      '" + depName + "': 'VARIABLE(S)_IT_BINDS_WITH',\n      ...\n      jquery: ['$', 'jQuery'],\n      backbone: ['Backbone']\n    }\n  ```\ninstead of the simpler\n  ```\n    dependencies: exports: bundle: [ '" + depName + "', 'jquery', 'backbone' ]\n  ```\n\nAlternativelly, pick one medicine :\n  - define at least one module that has this dependency + variable binding, using AMD instead of commonJs format, and uRequire will find it!\n  - declare it in the above format, but in `bundle.dependencies.depsVars` and uRequre will pick it from there!\n  - use an `rjs.shim`, and uRequire will pick it from there (@todo: NOT IMPLEMENTED YET!)");
            throw new UError(uerr);
          } else {
            if ((lenDiff = this.arrayDependencies.length - this.parameters.length) > 0) {
              for (paramIndex = _i = 1; 1 <= lenDiff ? _i <= lenDiff : _i >= lenDiff; paramIndex = 1 <= lenDiff ? ++_i : --_i) {
                this.parameters.push("__dummyParam" + paramIndex);
              }
            }
            for (_j = 0, _len = depsVars.length; _j < _len; _j++) {
              varName = depsVars[_j];
              if (!(__indexOf.call(this.parameters, varName) >= 0)) {
                d = new Dependency(depName, this.filename, this.bundle);
                this.arrayDependencies.push(d);
                this.nodeDependencies.push(d);
                this.parameters.push(varName);
                if (l.deb(99)) {
                  l.debug("" + this.modulePath + ": injected dependency '" + depName + "' as parameter '" + varName + "'");
                }
              } else {
                if (l.deb(90)) {
                  l.debug("" + this.modulePath + ": Not injecting dependency '" + depName + "' as parameter '" + varName + "' cause it already exists.");
                }
              }
            }
          }
        }
      }
      if (!(_.isEmpty(this.arrayDependencies) && ((_ref4 = this.build) != null ? _ref4.scanAllow : void 0) && !this.moduleInfo.rootExports)) {
        _ref5 = this.requireDependencies;
        for (_k = 0, _len1 = _ref5.length; _k < _len1; _k++) {
          reqDep = _ref5[_k];
          if (reqDep.pluginName !== 'node' && (_ref6 = reqDep.name({
            plugin: false
          }), __indexOf.call(this.bundle.dependencies.node, _ref6) < 0) && !(_.any(this.arrayDependencies, function(dep) {
            return dep.isEqual(reqDep);
          }))) {
            this.arrayDependencies.push(reqDep);
            if ((_ref7 = this.build) != null ? _ref7.allNodeRequires : void 0) {
              this.nodeDependencies.push(reqDep);
            }
          }
        }
      }
      this.webRootMap = this.bundle.webRootMap || '.';
      this.arrayDeps = (function() {
        var _l, _len2, _ref8, _results;
        _ref8 = this.arrayDependencies;
        _results = [];
        for (_l = 0, _len2 = _ref8.length; _l < _len2; _l++) {
          d = _ref8[_l];
          _results.push(d.name());
        }
        return _results;
      }).call(this);
      this.nodeDeps = (function() {
        var _l, _len2, _ref8, _results;
        _ref8 = this.nodeDependencies;
        _results = [];
        for (_l = 0, _len2 = _ref8.length; _l < _len2; _l++) {
          d = _ref8[_l];
          _results.push(d.name());
        }
        return _results;
      }).call(this);
      requireReplacements = {};
      _ref8 = _.flatten([this.arrayDependencies, this.requireDependencies, this.asyncDependencies]);
      for (_l = 0, _len2 = _ref8.length; _l < _len2; _l++) {
        dep = _ref8[_l];
        requireReplacements[dep.depString] = dep.pluginName === 'node' ? dep.name({
          plugin: false
        }) : dep.name();
        if (this.bundle.reporter) {
          this.bundle.reporter.addReportData(_B.okv({}, dep.type, [dep.name()]), this.modulePath);
        }
      }
      this.factoryBody = this.moduleManipulator.getFactoryWithReplacedRequires(requireReplacements);
      this.noRootExports = this.build.noRootExports;
      this.moduleTemplate = new ModuleGeneratorTemplates(this);
      l.verbose("Converting '" + this.modulePath + "' with template = '" + this.build.template.name + "'");
      if (l.deb(80)) {
        l.debug("module info = \n", _.pick(this, ['moduleName', 'moduleType', 'modulePath', 'arrayDeps', 'nodeDeps', 'parameters', 'webRootMap', 'rootExports']));
      }
      this.converted = this.moduleTemplate[this.build.template.name]();
      delete this.noRootExports;
    }
    return this;
  };

  /*
  Returns all deps in this module along with their corresponding parameters (variable names)
  
  Note: currently, only AMD-modules provide us with the variable-binding of dependencies!
  
  @param {Function} depFltr optional callback filtering dependency. Called with dep as param. Defaults to all-true fltr
  
  @return {Object}
      {
        jquery: ['$', 'jQuery']
        lodash: ['_']
        'models/person': ['pm']
      }
  */


  UModule.prototype.getDepsVars = function(depFltr) {
    var dep, depsVars, dv, idx, _i, _len, _name, _ref1, _ref2;
    if (depFltr == null) {
      depFltr = function() {
        return true;
      };
    }
    depsVars = {};
    if (this.isConvertible) {
      _ref1 = _.flatten([this.arrayDependencies, this.requireDependencies]);
      for (idx = _i = 0, _len = _ref1.length; _i < _len; idx = ++_i) {
        dep = _ref1[idx];
        if (!(depFltr(dep))) {
          continue;
        }
        dv = (depsVars[_name = dep.name({
          relativeType: 'bundle',
          plugin: false
        })] || (depsVars[_name] = []));
        if (this.parameters[idx] && !(_ref2 = this.parameters[idx], __indexOf.call(dv, _ref2) >= 0)) {
          dv.push(this.parameters[idx]);
        }
      }
      return depsVars;
    } else {
      return {};
    }
  };

  return UModule;

})(UResource);

module.exports = UModule;

/* Debug information*/

